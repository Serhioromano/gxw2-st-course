# Переменные

Переменные в GX Works 2 это достаточно большая тема, и не для всех она простая. Даже если у вас есть опыт программирования например в CoDeSys то здесь концепт немного другой и сначала может быть немного не привычно. С другой стороны если вы уже программировали ПЛК такие как Delta или Omron, то трудностей с пониманием может не возникнуть.

## Блоки (Devices)

В контроллерах Mitsubishi вся память разделена на разные области (`D`, `R`, `M`, `Y`, `X`, ...), и каждый блок области памяти пронумерован. Такой блок называют Device. Например `D100`, `M10`, `TC0`, `X001`, `R1000`. Блоки могут быть размером или 1-бит или 16-бит. Если мы храним значение больше чем 16-бит, то это значение просто занимает 2 или более блоков.

Давайте поговорим о самых важных для нас областях памяти.

### Область **X**

| Назначение   | Bit | Доступ | Диапазон      | Значения                    |
| ------------ | --- | ------ | ------------- | --------------------------- |
| Входное реле | 1   | Читать | `X000`~`X377` | `TRUE` или `FALSE`, 0 или 1 |

Область памяти напрямую связанная с аппаратными входами ПЛК. Писать в него нельзя, только читать. Блок `X000` это первый вход, `X001` второй и так далее. Всего **255** блоков.

!!! danger "**Считается восьмеричной системой**"

    На FX3G\FX3U данная область памяти считается в восьмеричном формате. Это значит что цифр 8 и 9 в счете нету. `Х0`, `X1`, `X2`, `X3`, `X4`, `X5`, `X6`, `X7`, `X10`, `X11`, и тд. `X0`~`X7`, `X10`~`X17`, `X20`~`X27`, ...

Когда на вход ПЛК поступает ток, этот блок меняет сове значение с `FALSE` на `TRUE` или с **0** на **1**. При сравнении данных с этого блока можно использовать как `TRUE`, `FALSE` так и **0**, **1**.

```iecst
IF X0 = 1 THEN
    Y0 := 1;
END_IF;

IF X2 = FALSE THEN
    Y0 := FALSE;
END_IF;
```

Это просто пример для демонстрации. Так ни кто не пишет естественно. Обычно выражение `IF X0 = 1 THEN` записывают `IF X0 THEN`, а `IF X2 = FALSE THEN` обычно пишут как `IF NOT X2 THEN`, тем не менее данный пример демонстрирует что можно использовать как `TRUE`, `FALSE` так и **0**, **1**.

### Область **Y**

| Назначение    | Bit | Доступ        | Диапазон      | Значения                    |
| ------------- | --- | ------------- | ------------- | --------------------------- |
| Выходное реле | 1   | Читать\Писать | `Y000`~`Y377` | `TRUE` или `FALSE`, 0 или 1 |

Область памяти напрямую связанная с аппаратными выходами ПЛК. Можно как и читать так и писать, но по сути они нужны чтобы именно писать в них.  Блок `Y0` это первый выход, `Y1` второй и так далее. Всего **255** блоков.

!!! danger "**Считается восьмеричной системой**"

    На FX3G\FX3U данная область памяти считается в восьмеричном формате. Это значит что цифр 8 и 9 в счете нету. `Y0`, `Y1`, `Y2`, `Y3`, `Y4`, `Y5`, `Y6`, `Y7`, `Y10`, `Y11`, и тд. `Y0`~`Y7`, `Y10`~`Y17`, `Y20`~`Y27`, ...

Если присвоить блоку `Y0` значение `TRUE` или **1** то ПЛК замкнет соответствующее выходу реле или транзистор если выход транзисторный.

```iecst
Y0 := X0;
Y1 := TRUE;
Y2 := Y0;
```

В первой строке видно что можно писать в блоки `Y` значения блоков `X` и как дальше увидим `M` и других блоков размером 1 бит, которые можно читать. А читать можно любые блоки.

В третей строке мы видим что можно читать из данного блока.

### Область **М**

| Назначение               | Bit | Доступ        | Диапазон        | Значения                    |
| ------------------------ | --- | ------------- | --------------- | --------------------------- |
| Обычные                  | 1   | Читать\Писать | `M0`~`M383`     | `TRUE` или `FALSE`, 0 или 1 |
| EEPROM энергонезависимые | 1   | Читать\Писать | `M384`~`M1535`  | `TRUE` или `FALSE`, 0 или 1 |
| Обычные                  | 1   | Читать\Писать | `M1536`~`M7679` | `TRUE` или `FALSE`, 0 или 1 |
| Системные                | 1   | Читать\Писать | `M8000`~`M8511` | `TRUE` или `FALSE`, 0 или 1 |

Это область дополнительных реле так сказать и связана с памятью ПЛК. Можно как и читать так и писать. Если вам нужно использовать данные блоки, так чтобы они сохраняли свои значения после перезагрузки ПЛК то нужно использовать диапазон `M384`~`M1535`. Этот диапазон используется для создания управляющих переменных например запуск двигателя если вы хотите чтобы после перезагрузки ПЛК, двигатель опять начал работу.

```iecst
IF X2 THEN
    M400 := TRUE;
END_IF;

IF X2 THEN
    M2000 := TRUE;
END_IF;
```

В данном примере если мы кратковременно подадим ток на вход `X2` то `M400` и `M2000` примут значение `TRUE`. Если после этого перегрузить ПЛК, то только `M400` сохранит значение `TRUE`, а `M2000` будет сброшено в `FALSE`.

<!-- Device number table
Name Contents
I/O relay
Input relay X0~X377 256 points It is octal number
Output relay Y000~Y377 256 points Total 512 I/O
Auxiliary relay
General M0~M383 384 points
EEPROM hold M384~M1535 1152 points
General M1536~M7679 6144 points
Special M8000~M8511 512 points
Status
Initial state (EEPROM hold) S0～S9 10 points
EEPROM hold S10～S999 990 points
General S1000～S4095 3096 points
Timer (ON delay timer)
100ms T0～T199 200 points 0.1～3,276.7s
10ms※1 T200～T245 46 points 0.01～327.67s
1ms accumulative (EEPROM hold) T246～T249 4 points 0.001～32.767s
100ms accumulative
(EEPROM hold) T250～T255 6 points 0.1～3,276.7s
1ms T256～T319 64 points 0.001~32.767s
Counter
General up counter (16bit) C0～C15 16 points 0～32,767 counter
EEPROM hold up counter
(16 bit) C16～C199 184 points 0～32,767 counter
General bi-direction (32 bit) C200～C219 20 points -2,147,483,648～
+2,147,483,647 counter
EEPROM hold bi-direction (32 bit) C220～C234 15 points -2,147,483,648～
+2,147,483,647 counter
High-speed counter
Single-phase single counter input
Bi-direction (32 bit) (EEPROM hold) C235～C245
-2,147,483,648～+2,147,483,647 Counter
Software counter
Single phase： at most 6 channel, 60kHz
Double phase： 1 times frequency:at most 2-3
channels, Max frequency 30KHz; M8198 is 4
times frequency sign of C251/C252.
4 times frequency:at most 2 channels,
24kHz,M8199 is 4 times frequency sign of
C253/C255. -->

## Объявление переменных

## Области видимости

В GX Works 2 есть несколько областей видимости переменных.

1. Глобальные
2. Локальные
   1. Локальные
   2. Входные
   3. Выходные
   4. Проходные

## Типы переменных

Типы переменных в GX Works 2 именуются отлично от стандарта МЭК-61131-3.

| Тип                              | Стандарт         | Описание                                                     |
| -------------------------------- | ---------------- | ------------------------------------------------------------ |
| Bit                              | `BOOL`, `BIT`    | Булева переменная занимает 1 бит.                            |
| Word[Signed]                     | `SINT`, `INT`    | Число со знаком 16-bit -32,768 до 32,767                     |
| Double Word[Signed]              | `DINT`           | Число со знаком 32-bit -65,536 до 65,535                     |
| Word[Unsigned/Bit String]        | `UINT`, `WORD`   | Число без знака 16-bit 0 до 2,147,483,648                    |
| Double Word[Unsigned/Bit String] | `UDINT`, `DWORD` | Число без знака 32-bit 0 до 4,294,967,296                    |
| FLOAT (Single precision)         | `REAL`           | С плавающей точкой 32-bit -2^128^ до +2^128^                 |
| Time                             | `TIME`           | Время 32-bit `T#-24d20h31m23s648ms` до `T#24d20h31m23s647ms` |

в GX Works 2 поддерживаются и другие типы данных. Например *FLOAT (Double precision)* это число с плавающей точкой но 64-bit. Или есть *String* как понятно из название это строка. Но они не поддерживаются в FX3G и FX3U по этому мы не будем их рассматривать.




## Глобальные

-65,536 to 65,535
0 to 4,294,967,296
2,147,483,648

Глобальнее переменные определяются в списке глобальны переменных.