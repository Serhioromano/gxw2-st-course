# Сценарий урока: Детальный разбор интерфейса GX Works 2

## Введение: Осваиваем кабину пилота

Здравствуйте! В предыдущем уроке мы успешно установили GX Works 2 и создали наш первый проект. Сегодня нас ждет, возможно, самый важный шаг на пути к мастерству — мы досконально изучим интерфейс программы.

Когда вы впервые открываете профессиональную программу, такую как эта, ощущения могут быть похожи на взгляд в кабину самолета. Сотни кнопок, меню, панелей... это может пугать и даже подрывать уверенность, что вы сможете все это осилить. Но я хочу вас заверить: **это абсолютно нормально**. Каждый пилот когда-то начинал с изучения одной-единственной кнопки. Наша задача — спокойно, шаг за шагом, разобраться в назначении каждого элемента. И я обещаю, когда мы закончим, вы посмотрите на все это и скажете: "Так вот как все просто!".

И это не просто слова для мотивации. Давайте на минуту остановимся и поговорим о том, какие **конкретные преимущества** в реальной работе дает доскональное знание этого "кокпита".

* Во-первых, это ваша **личная скорость и эффективность**. Глубокое знание инструментов позволяет в разы быстрее создавать, отлаживать, структурировать и поддерживать программы для ПЛК.
* Во-вторых, это **профессиональная гибкость**. Вы научитесь не просто писать код, а оптимизировать рабочие процессы и легко интегрировать ваши проекты с другими системами — например, с панелями оператора или SCADA-системами, что напрямую **снижает затраты на разработку**.
* И, возможно, самое главное — это **умение работать в команде и с чужим кодом**. Вы сможете без страха открывать проекты, написанные другими разработчиками, быстро в них разбираться и вносить правки. Это ключевой навык, который отличает новичка от опытного специалиста.

Поэтому, пожалуйста, не пропускайте эти уроки. Поверьте, они могут оказаться полезней и важней в дальнейшей практике, чем даже изучение самого языка. Этот урок — это инвестиция в вашу будущую скорость и уверенность.

Кстати, интерфейс GX Works 2 сделан приближенно к Visual Studio от Microsoft. Думаю, тем, кто открывал подобное, будет понятно большинство элементов интерфейса, что немного облегчит нашу задачу.

## 0️⃣ Терминология: Наш короткий язык

Прежде чем мы начнем разбирать интерфейс и как с ним взаимодействовать, давайте быстро запомним три термина, которые я буду постоянно использовать для краткости.

* **ЛКМ** — это один клик Левой Кнопкой Мыши. Самое обычное действие.
* **ПКМ** — это один клик Правой Кнопкой Мыши, который обычно вызывает контекстное меню с дополнительными опциями.
* **ДК** — это Двойной Клик левой кнопкой, который обычно что-то открывает или редактирует.

## 1️⃣ Меню: Карта всей программы

Как и в любой серьезной программе, в самом верху окна находится **главное меню**. Это — самый главный элемент управления. Можно сказать, что это карта всей программы, потому что здесь, в этих выпадающих списках, содержатся **абсолютно все** команды и функции, которые только есть в GX Works 2.

Мы не будем сейчас монотонно зачитывать каждый пункт. Без практического применения это бесполезно и моментально забудется. Мы будем знакомиться с командами постепенно, по мере необходимости.

И это касается всех элементов интерфейса, которые мы сегодня рассмотрим. Сейчас мы только в общих чертах по ним пройдемся и опишем базовые возможности. А по ходу нашего курса, уже в контексте конкретных задач, мы будем возвращаться к ним и узнавать их назначение и тонкости работы более подробно. Так что если сейчас вам покажется, что по каким-то элементам остались вопросы, не волнуйтесь. Я рассчитываю, что к концу курса не останется ни одной кнопки, команды, окна или панели, действие которой осталось бы для вас непонятным.

### Динамические меню: Инструмент-хамелеон

Есть один ключевой момент, который нужно упомянуть сразу. Обратите внимание на меню ++"View"++ (Вид) и ++"Edit"++ (Правка). Они — особенные. В отличие от других меню, их содержимое не постоянно. Оно **меняется в зависимости от типа документа**, который в данный момент открыт и активен в главной рабочей области.

Посмотрите: я выбираю Редактор Переменных, или как он здесь называется, *Labels*. Захожу в меню ++"View"++ — здесь одни пункты. Теперь я выбираю Редактор Кода — и меню ++"View"++ выглядит уже совсем по-другому. То же самое и с меню ++"Edit"++. Оно является динамическим, и набор его команд зависит от выбранного типа документа в рабочей области. Пример меню ++"Edit"++ мы увидим чуть позже.

### Навигация с клавиатуры: Путь к скорости

А теперь — первый секрет для тех, кто хочет работать быстро. Вы можете управлять всем меню, вообще не прикасаясь к мыши.

Нажмите и один раз отпустите клавишу ++alt++ на клавиатуре. Видите, как подсветился первый пункт меню "Project"? Это значит, что вы активировали режим навигации. Теперь клавишами-стрелками (++up++, ++down++, ++right++, ++left++) вы можете "гулять" по всему меню. Чтобы запустить выбранный пункт, используйте клавишу ++enter++. Если вы передумали и хотите выйти из этого режима, просто нажмите ++esc++.

Но есть способ еще быстрее. Заметили, что в названии каждого пункта меню одна буква **подчеркнута**? Это не для красоты. Это — горячая клавиша этого пункта.

Снова нажимаем и отпускаем ++alt++. А теперь, не используя стрелки, нажимаем на клавиатуре ту букву, которая подчеркнута в нужном нам меню. Например, мы хотим попасть в меню *Tools* (Инструменты). Там подчеркнута буква **T**. Нажимаю на клавиатуре ++"T"++ — и меню мгновенно открылось. Теперь смотрим на выпавший список. Хотим открыть *Options* (Настройки)? Подчеркнута буква **O**. Нажимаю ++"О"++ — и вот оно, окно настроек.

Со временем вы запомните самые частые комбинации. Попробуйте прямо сейчас: быстро, одна за другой, нажмите клавиши ++alt++, затем ++"T"++, затем ++"О"++. Буквально доля секунды — и окно открыто.

А если взять в расчет, что меню GX Works 2 содержит все команды, которые только возможны в этой программе, включая все, что есть на панелях инструментов, то можно даже не настраивать сложные "горячие клавиши", а просто запомнить эти последовательности. "Горячие клавиши" — это *одновременное* нажатие (например, Ctrl+C), а проход по меню — *последовательное*. Последовательности легче запомнить, и даже если вы забыли, всегда можно медленно пройти по меню через клавишу ++alt++ и вспомнить путь.

## 2️⃣ Панель инструментов: Быстрые кнопки

Под главным меню располагается **панель инструментов**. По сути, это просто набор иконок для самых популярных команд из меню. Если кликнуть **ПКМ** на пустом месте этой панели, появится меню, где можно включать и отключать целые группы инструментов. Давайте разберемся, что здесь есть.

### 1. Inelegant Function Module

Начнем с этой группы, потому что мы ее **никогда не будем использовать**. Она предназначена для работы со специальными внешними модулями для оригинальных контроллеров Mitsubishi. В нашем случае это неактуально. Чтобы она не занимала место и не сбивала с толку, давайте ее просто отключим.

### 2. Standard

Здесь собраны самые базовые действия: создать новый проект, открыть существующий, сохранить, напечатать. Также здесь есть кнопка **помощи** и **поиска по встроенной документации**.

К этой помощи нужно привыкнуть, но она может быть иногда полезна, чтобы быстро подсмотреть, какие параметры входят в инструкцию. Например, я постоянно забывал, в каком порядке идут параметры у инструкции `MOV`. Открываю помощь, нахожу `MOV` и быстро вижу, что есть 2 параметра: `S` (source, источник) и `D` (destination, приемник), и в каком порядке их вводить.

К сожалению, здесь нет примеров на языке ST. Зато они есть в других руководствах. В уже известной вам папке с материалами курса, если перейти в директорию `Documentation/EN/Mitsubishi/`, есть файл `FXCPU Structured Programming Manual [Basic & Applied Instruction].pdf`. Вот там уже все инструкции с примерами на ST, что бывает очень удобно.

### 3. Program Control

Этой группой мы будем пользоваться **постоянно**. Это наш главный пульт управления. Здесь есть стандартные команды копировать, вырезать, вставить, а также отменить (++"Undo"++) и повторить (++"Redo"++) последнее действие. Но самое главное — это кнопки, связанные с программой: компиляция, симуляция, загрузка в контроллер и мониторинг.

### 4. Docking Window/Switch Project Data

Этот набор кнопок просто включает и выключает видимость различных вспомогательных окон-навигаторов, которые мы разберем через минуту. Как пример, вот кнопка панели навигации по проекту: видите, она включает и выключает навигатор структуры проекта.

### 5. Dynamic

Ну и последняя группа. Я не знаю, что у вас будет тут, возможно, не то, что у меня. Эта последняя группа — **динамическая**, такая же, как и меню View, и зависит от **типа документа в рабочей области**. Нужно заметить, что инструменты каждой динамической группы появляются также и в меню ++"Edit"++.

Смотрите: выбираю редактор переменных — группа одна, и меню ++"Edit"++ выглядит так. Выбираю редактор кода — и группа панели инструментов изменилась, как и меню ++"Edit"++. О каждой из динамических групп мы так же поговорим позже, в контексте каждого типа документов.

## 3️⃣ Панель состояния: Ваш бортовой компьютер

В самом низу окна программы расположена **Панель состояния**. Многие новички не обращают на нее внимания, а зря. Это очень полезная информационная строка.

Здесь отображается ключевая информация о вашем проекте: например, выбранный тип ПЛК и тип проекта. А некоторые параметры здесь, как вы уже догадались, тоже **динамические** и меняются в зависимости от активного документа в рабочей области. Например, если вы работаете в редакторе кода, здесь будет отображаться номер текущей строки и столбца, где стоит курсор.

Если у вас маленький экран и каждый пиксель на счету, эту панель можно отключить через меню ++"View"++ -> ++"Status Bar"++. Но я рекомендую ее оставить.

## 4️⃣ Плавающие окна (Навигаторы): Ваши помощники

Теперь давайте поговорим об этих окнах, которые располагаются по бокам и внизу экрана. Я буду называть их **навигаторами** (привык к этому термину в EPLAN). Думайте о них как о ящиках или полках с инструментами, справочниках и блокнотах, разложенных на вашем рабочем столе, которые вы можете доставать, убирать или перемещать в удобное место.

### 1. Проект

Это — самое главное окно-навигатор. Это карта всего нашего проекта, представленная в виде **дерева**. Мы можем редактировать элементы этого дерева или добавлять в него новые, такие как программы, глобальные переменные, задачи, функциональные блоки и другое.

Здесь же есть еще две важные вкладки: **Библиотеки (Libraries)** и **Подключения (Connection)**. Вкладка "Библиотеки" позволяет создавать собственные или подключать готовые библиотеки, чем мы обязательно займемся позже. Вкладка "Подключения" позволяет настраивать параметры связи с ПЛК.

Кстати, обратите внимание на разделитель между окном, где отображается содержимое вкладки (в нашем случае — дерево проекта), и самими вкладками. Если у вас маленький экран, вы можете потянуть его вниз, и вкладки превратятся в компактные кнопки, экономя место. Имейте это в виду, если вкладки вдруг "пропадут" — возможно, они просто уменьшены до кнопок.

### 2. Элементы

В данном навигаторе представлены все инструкции, функции, функциональные блоки, которые мы можем использовать в программе. Этот навигатор **динамический** и будет отображать содержимое, только если открыт документ "Редактор программы".

По умолчанию этот навигатор показывает все возможные элементы одним большим списком. Но вот тут, сверху, у этого навигатора есть выпадающий список, который позволяет нам **отфильтровать** этот список. Можно выбрать, например, стандартную библиотеку, и тогда мы увидим, что наши функции и функциональные блоки более организованы по категориям. Так искать гораздо проще. В фильтре у нас есть базовые инструкции, инструкции программы а так же функции и Функциональные Блоки которые были созданы в проекте. Если в библиотеке у нас есть подключенная или созданная библиотека, то в этом селекторе она тоже появится.

#### Способы вставки инструкций

Раз уж мы говорим о списке инструкций, давайте сразу научимся вставлять их в программу. Есть несколько способов:

Есть 3 способа вставки инструкций.

1. Просто напечатать ее в редакторе программы. Именно таким я пользуюсь чаще всего. По сути данным навигатором я ни когда не пользовался но понимаю что для многих он будет удобно, поэтому подробно о нем говорю. Поставим курсор в редакторе программы и напишу `BMOV`. Это инструкция заполнения группы регистров расположенных подряд определенным значением. Удалим вставку.

2. Второй способ это двойной клик на имени инструкции в этом навигаторе. Давайте перейдем в *Application Instructions -> Move and Compare* и дважды кликнем на инструкции `BMOV`.  Мы видим что имя вставилось в текст программы. Удалим вставку.

3. Третий способ это перетащить инструкцию из навигатора в редактор программы. Давайте перетащим `BMOV` в редактор. Мы видим что мы вставили не только имя инструкции но и шаблон ввода. Шаблон ввода помогает нам видеть какие возможны параметры ввода. Если мы например перетащим Функциональный Блок например я перетащу `TOF` нам предложат создать конечно имя для него, мы это окно позже подробно заберем, но после этого шаблон ввода будет содержать и имена входных переменных. Я пока это удалю.

    Но что самое интересное что после вставки шаблона, мы можем быстро переходить от одного параметра к другому при помощи быстрых клавиш ++ctrl+alt+right++ и ++ctrl+alt+left++. При этом шаблон ввода сразу выделяется и нам только остается ввести данные.

Кажется что перетаскивать инструкции на много удобней. Почему же я сказал что не пользуюсь этим навигатором? Есть возможность добавить шаблон ввода по быстрой клавише ++ctrl+"F1"++. Запомните это сочетание, вы будете его использовать очень часто.

Смотрите все удаляем. Вводим руками `BMOV` и нажмем сочетание клавиш ++ctrl+"F1"++ на клавиатуре. Все шаблон вставлен. Теперь клавишами ++ctrl+alt+right++ выделяем нужный нам параметр и вписываем нужное значение, и так до конца.

#### Способы вставки инструкций: от новичка до профессионала

Раз уж мы заговорили об этом навигаторе со списком инструкций, это идеальный момент, чтобы научиться самому главному: как вставлять эти инструкции в нашу программу. Давайте разберем несколько способов, от самых очевидных до тех, которыми пользуются опытные разработчики.

**Способ 1: Ручной ввод с клавиатуры**

Первый способ, самый прямой и очевидный — просто напечатать имя инструкции с клавиатуры. Если вы точно знаете, что вам нужно, например, инструкция `BMOV` (это, кстати, инструкция для блочного перемещения данных), вы просто ставите курсор в редактор и пишете ее. Честно говоря, этим способом я пользуюсь чаще всего, потому что это очень быстро, когда уже есть опыт. Но для новичка он может быть сложным, так как легко допустить опечатку в имени инструкции, и тогда программа выдаст ошибку.

**Способы 2: Двойной клик в навигаторе**

Второй способ — использовать наш навигатор "Элементы" как интерактивный справочник. Это отлично подходит, когда вы не уверены в точном названии или просто изучаете, какие инструкции вообще существуют.

Давайте для примера найдем ту же инструкцию `BMOV`. Вот она, в разделе *Application Instructions -> Move and Compare*. Теперь я просто делаю по ней двойной клик мыши... и посмотрите, ее имя тут же появилось в коде в том месте, где стоял курсор. Никаких опечаток, все точно и просто.

**Способ 3: Перетаскивание (Drag-and-drop)**

Третий способ, и, возможно, самый полезный для начинающих, — это перетаскивание. Я зажимаю левую кнопку мыши на нашей инструкции `BMOV` и, не отпуская, тащу ее прямо в окно с кодом. Отпускаю — и посмотрите, что произошло!

Вставилось не просто имя, а целый **шаблон для ввода**! Программа сама подсказывает нам, какие параметры (`s`, `n`, `d`) нужно ввести. Это невероятно удобно, потому что защищает от синтаксических ошибок и вам не нужно помнить наизусть все аргументы функции. То же самое произойдет, если перетащить, например, функциональный блок `TOF` (таймер с задержкой выключения). Программа сначала предложит задать ему имя, а затем вставит шаблон с именами всех его входов и выходов.

!!! tip "**Маленький трюк:**"

    Когда у вас есть такой шаблон, вы можете легко переключаться между его параметрами, нажимая ++ctrl+alt+right++ и ++ctrl+alt+left++. Посмотрите, курсор сам перепрыгивает на следующий параметр и сразу выделяет его, готовый к вводу. Это очень ускоряет заполнение.

**Профессиональный способ: Скорость и удобство**

Итак, кажется, что перетаскивание — лучший способ, верно? Удобно, с подсказками. Так почему же я сказал, что почти не пользуюсь этим навигатором?

А вот и главный секрет, которым пользуются опытные разработчики. Существует способ, который объединяет **скорость ручного набора** и **удобство шаблона**. Запомните это волшебное сочетание клавиш: ++ctrl+"F1"++. Вы будете использовать его постоянно.

Давайте я покажу, как это работает.

1. Я удаляю все из редактора.
2. Как и в первом способе, я просто печатаю `BMOV`.
3. А теперь, пока курсор находится на имени инструкции, я нажимаю ++ctrl+"F1"++.

И вуаля! Тот же самый шаблон вставлен! Никаких мышей, никаких перетаскиваний. Быстро, просто и с подсказками.

```iecst
BMOV(TRUE,D90,1,D100);
```

**Так какой же способ выбрать?**

Я думаю, ваш рабочий процесс со временем будет выглядеть так:

* Если вы **точно помните** имя инструкции, вы печатаете его и нажимаете ++ctrl+"F1"++ для вставки шаблона.
* Если же вы **не уверены** в названии или хотите посмотреть, какие вообще есть варианты, вы открываете навигатор "Элементы", находите там нужную инструкцию в категориях, а затем либо перетаскиваете ее, либо просто смотрите имя и вводите его вручную, используя ++ctrl+"F1"++.

Я думаю что порядок действий у вас будет такой. Если вы помните или знаете имя инструкции которую вам нужно вставить вы просто пишите ее в программе, вставляете шаблон клавишами ++ctrl+"F1"++ и заполняете, если вы не помните как она пишется, или вам нужно посмотреть что вообще есть, то вы идете в этот навигатор, ищите нужную группу например арифметика, смотрите то есть и перетаскиваете нужную инструкцию.

### 3. Output (Вывод): Ваш центр уведомлений

Следующий навигатор в нашем списке — это **Output**, или, по-русски, **Вывод**. Эту панель вы большую часть времени будете видеть пустой, но она становится абсолютно незаменимой в момент, когда вы нажимаете кнопку "Компилировать". Представьте, что это ваш личный корректор или строгий учитель, который проверяет вашу работу на ошибки.

Именно здесь, в этом окне, программа будет с вами общаться. Она будет показывать не только критические **ошибки**, из-за которых программа не может быть создана, но и **предупреждения** (warnings) о потенциальных проблемах, а также просто информационные **уведомления** о ходе процесса.

Давайте я продемонстрирую это на простом примере.

(На экране демонстрируется компиляция простого, корректного кода). Вот, смотрите, я компилирую нашу программу, в которой сейчас нет ошибок. Окно "Output" сообщает нам, что все прошло успешно: "0 ошибок, 0 предупреждений". Все чисто.

(На экране в код намеренно вносится ошибка, например, убирается точка с запятой). А теперь я намеренно допущу ошибку в коде — например, уберу точку с запятой в конце строки. Снова нажимаю "Компилировать"... и посмотрите! Окно "Output" тут же "загорелось красным". Оно не просто говорит, что есть ошибка, но и пишет ее описание и, что самое важное, указывает на строку в коде, где эта ошибка произошла. Двойной клик по этой строке в окне "Output" сразу же перенесет наш курсор в проблемное место в редакторе. Это невероятно ускоряет процесс отладки.

### 4. Cross Reference (Перекрестные ссылки): Ваш главный детектив

А вот этот инструмент, **Cross Reference** или **Перекрестные ссылки**, — это, без преувеличения, ваш личный детектив и один из самых мощных инструментов в арсенале разработчика. Его задача — найти **абсолютно все места** в вашем проекте, где используется, читается или изменяется любая переменная или регистр.

Представьте, что у вас проект на тысячи строк кода, и вам нужно понять, где именно используется переменная `motor_speed`. Искать вручную — невозможно. Этот навигатор сделает это за секунду.

У этого инструмента есть одно важное требование: он работает на основе скомпилированных данных. Это значит, что прежде чем его использовать, ваша программа должна быть успешно скомпилирована. Почему? Потому что именно во время компиляции программа создает полную карту всех переменных и их использований. Мы как раз только что компилировали программу, так что все готово для демонстрации.

Посмотрите вот сюда, в выпадающий список. По умолчанию здесь выбрано `All Device\Label`, что дословно значит "Все устройства и метки". Это режим поиска по всему и вся. Давайте нажмем кнопку "Find" (Найти). В окне результатов мы видим список всех регистров, которые нашла программа. Вот, например, наши `D90` и `D100`. Если бы мы использовали не прямые адреса памяти, а переменные с осмысленными именами, например, `motor_speed`, то здесь отобразилось бы именно это имя.

Этот список можно фильтровать. Например, если нас интересует только регистр `D100`, мы можем ввести его имя в поле для поиска и нажать "Find" еще раз. Теперь в результатах только то, что нам нужно.

А самое удобное — это то, что результаты интерактивны. Если я сделаю двойной клик по любой строке в этом списке, посмотрите — мой курсор мгновенно перепрыгивает на ту самую строку в редакторе кода, где используется этот регистр. Это невероятно удобно.

Давайте усложним пример. Я добавлю в код еще одну строку, где используется `D100`.

```iecst
BMOV(TRUE,D90,1,D100);
D100 := 10;
```

Теперь мне нужно снова **скомпилировать** программу, чтобы карта переменных обновилась. Готово. Провожу поиск снова... И вот, посмотрите, теперь в результатах для `D100` мы видим две строки. Навигатор нашел оба места использования. Как я и говорил, это работает не только для регистров, но и для любых переменных с именами (так называемыми символьными переменными), что делает код намного более читаемым и удобным для отладки.

Сейчас это может показаться простым, но поверьте, когда мы будем работать над большим проектом в теме по отладке, вы по-настоящему оцените всю мощь этого инструмента.

### 5. Device List (Список регистров): Карта занятой памяти

Следующий полезный инструмент — **Device List**, или **Список регистров**. "Device" в контексте Mitsubishi — это общее название для ячеек памяти: регистров, входов, выходов, таймеров и так далее. Этот навигатор — ваш способ заглянуть в память контроллера и понять, какие адреса вы уже использовали в своей программе, а какие еще свободны. Это как посмотреть план парковки, чтобы понять, какие места заняты, а куда можно встать.

Давайте посмотрим, как это работает. В поле для поиска я введу адрес, с которого хочу начать проверку, например, `D90`, и нажму "Find". Программа показывает мне список регистров, и мы видим, что наши `D90` и `D100` отмечены как используемые. Это очень важная функция, которая страхует вас от одной из самых частых ошибок — случайного использования одного и того же регистра для двух разных задач, что привело бы к непредсказуемому поведению программы.

Но самая главная "фишка" этого навигатора — это его тесная интеграция с "Перекрестными ссылками", о которых мы только что говорили. Эти два инструмента работают в паре, как детектив и его помощник с архивом.

Смотрите, что произойдет. Я нахожу в списке наш занятый регистр `D100` и делаю по нему двойной клик. И мгновенно... посмотрите... фокус переключается на навигатор "Cross Reference", и он автоматически выполняет поиск по `D100`, показывая нам все места, где используется этот регистр. Это невероятно удобно: сначала вы видите, *что* регистр занят, а потом одним кликом узнаете, *где именно* и *как* он занят.

Как и с перекрестными ссылками, всю прелесть этого инструмента мы по-настоящему ощутим, когда будем отлаживать большие, сложные приложения. К этому мы еще вернемся.

### 6. Device Reference и другие навигаторы для модулей

Следующие несколько навигаторов в списке, такие как **Device Reference** и **Integrated Function Module Monitor**, мы подробно разбирать не будем, и вот почему. Все они предназначены для углубленной работы с внешними, физически подключаемыми модулями расширения для оригинальных контроллеров Mitsubishi. Например, `Device Reference` — это редактор для навигации по регистрам в этих модулях, а `Integrated Function Module Monitor` — это, по сути, такое же окно наблюдения, как и `Watch`, но специально для тех самых внешних модулей.

Поскольку мы работаем с контроллером Coolmay L02, где все входы и выходы уже встроены, эти инструменты нам просто не пригодятся. Поэтому мы не будем на них останавливаться, чтобы не перегружать вас лишней информацией.

### 7. Watch (Окно наблюдения): Наши глаза в мире ПЛК

А вот следующий пункт, **Watch**, — это один из важнейших инструментов для отладки, наши будущие "глаза" внутри работающей программы.

Как вы видите, это не просто одна кнопка, а выпадающее меню, предлагающее нам целых четыре одинаковых окна: `Watch 1`, `Watch 2`, `Watch 3` и `Watch 4`. Зачем так много? Это сделано для вашего удобства. Вы можете организовать переменные, за которыми хотите следить, в разные группы. Например, в первом окне — переменные, отвечающие за один механизм, во втором — за другой, в третьем — общие системные флаги и так далее. Это позволяет не создавать "кашу" из сотен переменных в одном списке.

В этих окнах, когда мы подключимся к контроллеру в режиме отладки или мониторинга, мы сможем в реальном времени не только **видеть**, как меняются значения наших переменных, но и **принудительно изменять их**! Это очень мощная функция для тестирования. Например, вы можете вручную изменить значение какой-нибудь настройки или уставки, чтобы проверить, как на это отреагирует ваша программа. А в режиме симуляции можно даже менять значения входов и выходов.

Особенно удобно в этом окне просматривать массивы, в том числе и массивы структур, что часто просто не возможно сделать в мониторинге в рабочей области.

Вы можете спросить: "Но ведь в режиме отладки значения переменных и так видны прямо в редакторе кода?" И это правда. Но представьте, что вам нужно одновременно следить за десятью переменными, которые находятся в разных частях программы. В редакторе вам пришлось бы постоянно прокручивать код вверх и вниз. Это неудобно. Окно `Watch` решает эту проблему. Вы можете добавить в него только те переменные, которые важны для текущей задачи, даже если они из разных программных блоков, и видеть их все вместе в одном компактном списке. Это позволяет сфокусироваться на главном.

Мы не будем сейчас подробно на нем останавливаться, так как его работа имеет смысл только в контексте подключении к контроллеру. Мы посвятим ему много времени в уроках, посвященных онлайн-мониторингу и отладке.

### 8. Find (Поиск): Наш универсальный искатель

И последний навигатор в нашем списке — это Find, или Поиск. В отличие от Перекрестных ссылок", которые "понимают" структуру кода, "Поиск" — это более простой, но очень быстрый инструмент, работающий как поиск в вашем браузере или Блокноте (обычно по клавишам ++ctrl+"F"++).

Лично я его никуда не прикрепляю, а просто оставляю плавающим по центру экрана, потому что обычно его открываешь для одной конкретной задачи, а после выполнения — сразу закрываешь.

Как видите, в этом окне есть несколько вкладок. Они позволяют вам сузить область поиска: можно искать только регистры, только инструкции или, как я предпочитаю делать чаще всего, — строки (Strings). Поиск по строкам универсален: он найдет все, что вы ищете, будь то имя переменной, адрес регистра или часть комментария.

Например, (на экране демонстрируется поиск) я ввожу `BMOV` и нажимаю "Найти все". Вот результат. Теперь ввожу `D100` — и он находит и этот регистр. Если бы у нас были переменные с именами, он бы нашел и их.

### Общие принципы размещения навигаторов

Итак, мы кратко рассмотрели назначение основных навигаторов. Конечно, мы будем возвращаться к ним и изучать их более подробно, когда будем решать практические задачи. А сейчас давайте поговорим об общих принципах управления этими окнами.

Посмотрите на заголовок любого навигатора. Вы видите этот маленький значок булавки? Он работает как переключатель. Когда булавка "воткнута", окно постоянно закреплено и видимо. Если на нее нажать, булавка повернется, и окно "открепится" — оно скроется в маленькую вкладку сбоку экрана. (На экране демонстрируется). Теперь, если я просто наведу мышь на эту вкладку, окно плавно "выедет" поверх рабочей области. Убираю мышь — оно снова скроется. Это невероятно полезная функция, если вы работаете на ноутбуке с маленьким экраном, где важен каждый сантиметр. Чтобы снова закрепить окно, нужно просто еще раз нажать на эту булавку.

Но это еще не все. Вы — хозяин своего рабочего пространства. Если вы зажмете ЛКМ на заголовке любого навигатора и потащите его, он "отцепится" и станет отдельным, независимым окном. Такое окно можно даже перенести на второй монитор, если вы, как и я, работаете с несколькими. (На экране демонстрируется). Если же вы начнете тащить это окно поверх основного, посмотрите — появляются специальные стрелки-магниты. Они показывают, куда можно "примагнитить" это окно. Просто наведите его на одну из стрелок, и программа подсветит синим область, которую займет окно. Так вы можете выстроить интерфейс именно так, как удобно вам.

## 5️⃣ Рабочая область

Это окно в котором мы видим открытые документы проекта. В верху этой области мы видим вкладки, каждая из которых представляет один документ. На каждой вкладке видно имя документа а так же иконка что в купе помогает нам понять какой это тип документа. А в низу мы видим окно документа, где отображается его содержимое. Переходя по вкладкам, мы меняем содержимое окна. Прямо сейчас у нас открыто 2 документа это документ Редактор переменных, и Редактор программы. Закрыть любой документ можно нажав на крестик. ДК в дереве проекта на документах и открою их снова.

С права мы видим кнопки навигации по документам. Кнопки вправо влево передвигают вкладки по зоне видимости. Эти кнопки нужны только если у нас открыто столько документов, что их вкладки не помещаются в ширину экрана. Давайте продемонстрирую, сделаю окно поменьше, теперь нажимая стрелки я могу перемещать зону видимости вкладок.

В самом краю треугольник позволяет в выпадающем списке увидеть весь список открытых документов. Повторюсь это необходимо только если у вас очень много открытых документов.

Есть еще одна удобная функция, если ПКМ на любой вкладке, то через открывшееся контекстное меню, мы сможем закрыть это окно, или закрыть все окна с права или слева от него, ну или сразу и справа и слева одной командой, ну или закрыть сразу все окна. Я этим пользуюсь не редко.

Перемещаться по документам можно так же при помощи горячих клавиш. ++ctrl+tab++ для перемещения на одну вкладку в влево и ++ctrl+shift+tab++ для перемещения на одну вкладку в право. Для перехода на вкладку вправо есть еще одна горячая клавиша это ++ctrl+"F6"++. Если мы достигли последней вкладки перемещаясь в право или влево, то мы по кругу перейдем к вкладке с другой стороны. Давайте открою еще один документ Мониторинга буфера, и смотрите если я нажимаю ++ctrl+shift+tab++ мы передвигаемся по вкладками с лева на право закольцовано, а если ++ctrl+tab++ то закольцовано с права на лево.

Закрыть документ можно при помощи клавиш ++ctrl+"F4"++.

По умолчанию мы можем видеть только одно окно которое занимает всю рабочую область. Но это не всегда бывает удобно. Иногда хочет открыть и вдеть содержимое сразу нескольких окон. Если мы попытаемся перетащить вкладку, как навигатор, то ни чего не получится. Для этого в меню Window, есть первые 3 команды.

**1. Cascade**

Каскад позволяет нам превратить каждый документ в отдельное окно на рабочей области. Мы можем свободно перемещать, масштабировать эти окна или свернуть. Если окно свернуть оно попадает вот сюда. Можно его развернуть. С верху находится текущее активное окно документа. Навигация по окнам в виде вкладок и быстрых клавиш остается полностью рабочей, так что если одно окно перекрывает другое, при помощи навигации можно переместить это окно наверх сделав активным.

**2. Tile Vertically и Tile Horizontally**

Это практически тоже самое что и каскад, они превращают документы в отдельные окна, только при этом автоматически выравнивают их по рабочей области. Я например часто пользуюсь *Tile Vertically*. Например мне нужно 2 параллельно открытых окна. Я закрываю все окна кроме этих 2х окон и нажимаю ++alt+"W"+"V"++, что соответствует меню *Window -> Tile Vertically*. И вуаля. 2 окна.

Но это работает только если у нас небольшие 3х окон. Вот смотрите я открою еще одно окно и того 3, тогда Tile Vertically и Tile Horizontally работают как ожидается. Вот вертикально, вот горизонтально. Открою еще одно окно четвертое. Теперь программа пытается автоматически равномерно распределить рабочую область на каждое окно и на той и на другой команде. Для пример открою еще одно пятое окно, и вот как распределение работает сейчас.

